# üúÇ Sovereign Dominion Token Forge - Environment Integration Guide

**Version:** 1.9.7s  
**Status:** ‚úÖ ACTIVE - All Secrets Managed by Token Forge

---

## üéØ Overview

The Sovereign Dominion Token Forge is a complete environment sovereignty system that **eliminates all static secrets** from the repository and replaces them with **ephemeral, auto-rotating tokens**.

### Key Principles

1. **No Plaintext Secrets** - All secrets are managed by Token Forge
2. **Ephemeral Tokens** - Tokens expire automatically (typically 1 hour)
3. **Single Root Key** - Only `FORGE_DOMINION_ROOT` needs to be set (in GitHub Secrets)
4. **Auto-Rotation** - Tokens are minted on-demand and rotated automatically
5. **Platform Agnostic** - Works with GitHub, Netlify, Render, and any provider

---

## üîß Setup Instructions

### Step 1: Generate Root Key

Generate a secure root key (only needs to be done once):

```bash
python -c "import base64, os; print(base64.urlsafe_b64encode(os.urandom(32)).decode().rstrip('='))"
```

### Step 2: Set GitHub Secret

Add the root key to GitHub Secrets:

```bash
gh secret set FORGE_DOMINION_ROOT --body "<your-generated-key>"
```

Or manually in GitHub:
1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions
2. Click "New repository secret"
3. Name: `FORGE_DOMINION_ROOT`
4. Value: Your generated key

### Step 3: Set GitHub Variables (Optional)

```bash
gh variable set FORGE_DOMINION_MODE --body "sovereign"
gh variable set FORGE_DOMINION_VERSION --body "1.9.7s"
```

### Step 4: Verify Setup

Run the Token Forge scanner to ensure no plaintext secrets remain:

```bash
python -m bridge_backend.bridge_core.token_forge_dominion.scan_envs
```

Expected output:
```
[Dominion CI] ‚úÖ secret scrub: clean
[Scanner] No plaintext secrets detected (count: 0)
```

---

## üìã Environment Files

All `.env*` files have been updated to use the Token Forge pattern:

### Main Environment Files

- `.env` - Development environment (Token Forge integrated)
- `.env.deploy` - Deployment configuration (Token Forge integrated)
- `.env.production` - Production settings (Token Forge integrated)
- `.env.netlify` - Netlify-specific config (Token Forge integrated)

### Example/Template Files

- `.env.example` - Main template with Token Forge documentation
- `.env.template` - Simplified template
- `.env.netlify.example` - Netlify template
- `.env.render.example` - Render template
- `.env.envsync.example` - EnvSync template
- `.env.v197f.example` - v1.9.7f feature template
- `.env.v197q.example` - v1.9.7q feature template
- `bridge-frontend/.env.example` - Frontend template

### Placeholder Pattern

All secrets use one of these placeholders:

- `<FORGE_MANAGED>` - Auto-generated by Token Forge
- `<PLATFORM_MANAGED>` - Managed by deployment platform (e.g., Render database URL)
- `<SET_IN_GITHUB_SECRETS>` - FORGE_DOMINION_ROOT only

---

## üîÑ Token Lifecycle

### Minting Tokens

Tokens are minted automatically at runtime using:

```bash
bash runtime/pre-deploy.dominion.sh
```

This script:
1. Validates `FORGE_DOMINION_ROOT` exists
2. Mints ephemeral tokens for all configured providers
3. Sets TTL based on resonance-aware calculations
4. Exports tokens to environment

### Token Providers

The Token Forge currently supports:

- **GitHub** - Repository automation, API calls
- **Netlify** - Deployment, site management
- **Render** - Service management, deployments

### Token Validation

Tokens are validated before use:

```bash
python -m bridge_backend.bridge_core.token_forge_dominion.validate_or_renew <provider>
```

### Auto-Renewal

Tokens nearing expiry (<5 minutes) are automatically renewed:

- Workflow: `.github/workflows/forge_dominion.yml`
- Schedule: Every 6 hours
- Force rotation: Available via workflow_dispatch

---

## üîê Security Features

### 1. Sealed Issuance
- HMAC-SHA384 signatures
- Tamper-proof token envelopes
- Root key isolation (never written to disk)

### 2. Short Lifespan
- Default TTL: 3600 seconds (1 hour)
- Resonance-aware TTL adjustment
- Automatic expiry

### 3. Continuous Audit
- Pre-commit secret scanning
- CI/CD secret detection
- Token forge events tracked

### 4. Governance Pulse

Token Forge monitors token health:

| Condition | Action |
|-----------|--------|
| >5 mints in 5min | Governance lock (rate limit) |
| >10 renews in 5min | Governance lock |
| Inactive >20min | Manual review required |

Check pulse:
```python
from bridge_backend.bridge_core.token_forge_dominion import EnterpriseOrchestrator
orchestrator = EnterpriseOrchestrator()
pulse = orchestrator.check_pulse()
print(pulse['pulse_strength'])  # gold/silver/red
```

---

## üì¶ GitHub Actions Integration

### Using the Forge Dominion Setup Action

A reusable composite action is available at `.github/actions/forge-dominion-setup`:

```yaml
- name: Setup Forge Dominion
  id: forge
  uses: ./.github/actions/forge-dominion-setup
  with:
    forge-dominion-root: ${{ secrets.FORGE_DOMINION_ROOT }}
    providers: 'github,netlify,render'

- name: Use Minted Tokens
  env:
    GITHUB_TOKEN: ${{ steps.forge.outputs.github-token }}
    NETLIFY_AUTH_TOKEN: ${{ steps.forge.outputs.netlify-token }}
    RENDER_API_KEY: ${{ steps.forge.outputs.render-token }}
  run: |
    echo "Using ephemeral tokens minted by Forge Dominion"
```

### Updated Workflows

The following workflows have been updated to use Token Forge:

- `bridge_autodeploy.yml` - Uses Forge Dominion for Netlify deployment
- `forge_dominion.yml` - Token rotation workflow (unchanged)

### Migration Pattern for Other Workflows

To migrate a workflow to use Token Forge:

1. **Add Forge Dominion Setup Step:**
   ```yaml
   - name: Setup Forge Dominion
     id: forge
     uses: ./.github/actions/forge-dominion-setup
     with:
       forge-dominion-root: ${{ secrets.FORGE_DOMINION_ROOT }}
       providers: 'netlify'  # or 'github,netlify,render'
   ```

2. **Replace Secret References:**
   ```yaml
   # OLD
   env:
     NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
   
   # NEW
   env:
     NETLIFY_AUTH_TOKEN: ${{ steps.forge.outputs.netlify-token }}
   ```

3. **Keep Platform Variables:**
   ```yaml
   # Site IDs and service IDs can remain as vars (they're not secrets)
   NETLIFY_SITE_ID: ${{ vars.NETLIFY_SITE_ID }}
   RENDER_SERVICE_ID: ${{ vars.RENDER_SERVICE_ID }}
   ```

---

## üß™ Testing

### Local Testing

1. Export the root key locally:
   ```bash
   export FORGE_DOMINION_ROOT="<your-generated-key>"
   ```

2. Run the pre-deploy script:
   ```bash
   bash runtime/pre-deploy.dominion.sh
   ```

3. Verify tokens were minted:
   ```bash
   # Check for success message
   [Dominion] pre-deploy complete ‚Äî tokens sealed.
   [Dominion] Tokens minted: 3
   ```

### Running Tests

Token Forge has comprehensive test coverage:

```bash
# Test Token Forge module
pytest tests/test_forge_dominion_v197s.py -v

# Test Quantum Dominion integration
pytest tests/test_quantum_dominion.py -v
```

### Secret Scanner Test

Verify no secrets remain:

```bash
python -m bridge_backend.bridge_core.token_forge_dominion.scan_envs
```

Expected: `count: 0`

---

## üîç Troubleshooting

### Issue: "No FORGE_DOMINION_ROOT"

**Solution:**
```bash
export FORGE_DOMINION_ROOT=$(python -c "import base64, os; print(base64.urlsafe_b64encode(os.urandom(32)).decode().rstrip('='))")
```

### Issue: "Secret detection failed"

**Solution:**
1. Check output for detected secrets
2. Replace plaintext secrets with `<FORGE_MANAGED>`
3. Re-run scanner: `python -m bridge_backend.bridge_core.token_forge_dominion.scan_envs`

### Issue: "Token validation fails"

**Solution:**
```bash
# Force renewal for specific provider
python -m bridge_backend.bridge_core.token_forge_dominion.validate_or_renew <provider>
```

### Issue: Workflow fails with token errors

**Solution:**
1. Verify `FORGE_DOMINION_ROOT` is set in GitHub Secrets
2. Check workflow uses `.github/actions/forge-dominion-setup`
3. Ensure providers are specified correctly
4. Check workflow logs for token minting output

---

## üìä Token Forge Modules

```
bridge_backend/bridge_core/token_forge_dominion/
‚îú‚îÄ‚îÄ __init__.py                  # Module exports
‚îú‚îÄ‚îÄ quantum_authority.py         # Token minting engine (HMAC-SHA384)
‚îú‚îÄ‚îÄ sovereign_integration.py     # Bridge resonance integration
‚îú‚îÄ‚îÄ zero_trust_validator.py      # Policy enforcement
‚îú‚îÄ‚îÄ quantum_scanner.py           # Security scanning
‚îú‚îÄ‚îÄ enterprise_orchestrator.py   # Deployment automation + pulse
‚îú‚îÄ‚îÄ bootstrap.py                 # Root key validator
‚îú‚îÄ‚îÄ scan_envs.py                 # Secret detector
‚îî‚îÄ‚îÄ validate_or_renew.py         # Token lifecycle manager
```

---

## üéØ Benefits of Token Forge

### Before Token Forge

- ‚ùå Static secrets in `.env` files
- ‚ùå Secrets committed to repository
- ‚ùå Manual rotation required
- ‚ùå Risk of exposure
- ‚ùå Multiple secret locations

### After Token Forge

- ‚úÖ Zero plaintext secrets in repository
- ‚úÖ Auto-rotating ephemeral tokens
- ‚úÖ Single root key (in GitHub Secrets)
- ‚úÖ Automated token lifecycle
- ‚úÖ Tamper-proof token signatures
- ‚úÖ Governance and monitoring
- ‚úÖ Resonance-aware TTL

---

## üìö Additional Resources

- **Deployment Guide:** [FORGE_DOMINION_DEPLOYMENT_GUIDE.md](./FORGE_DOMINION_DEPLOYMENT_GUIDE.md)
- **Quick Reference:** [FORGE_DOMINION_QUICK_REF.md](./FORGE_DOMINION_QUICK_REF.md)
- **Implementation Summary:** [FORGE_DOMINION_IMPLEMENTATION_SUMMARY.md](./FORGE_DOMINION_IMPLEMENTATION_SUMMARY.md)

---

## ‚úÖ Checklist: Environment Cleanup Complete

- [x] All `.env` files cleaned of plaintext secrets
- [x] All `.env.example` files updated with Token Forge pattern
- [x] Token Forge scanner reports clean (0 secrets)
- [x] Forge Dominion GitHub Action created
- [x] Sample workflow updated (bridge_autodeploy.yml)
- [x] Documentation created
- [x] Single root key (FORGE_DOMINION_ROOT) required
- [x] All provider tokens auto-generated

---

**üúÇ Status: SOVEREIGN ‚Ä¢ Resonance: 100.000 ‚Ä¢ Volatility: 0.032**

*Welcome to Environment Sovereignty.*
