"""
Tests for ARIE Adapters (Genesis, Permission, Truth, Cascade, Blueprint)
"""

import unittest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, UTC

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

from bridge_core.engines.adapters.arie_genesis_link import ARIEGenesisLink
from bridge_core.engines.adapters.arie_permission_link import ARIEPermissionLink
from bridge_core.engines.adapters.arie_truth_link import ARIETruthLink
from bridge_core.engines.adapters.arie_cascade_link import ARIECascadeLink
from bridge_core.engines.adapters.arie_blueprint_link import ARIEBlueprintLink
from engines.arie.models import Summary, PolicyType, Patch


class TestARIEGenesisLink(unittest.TestCase):
    """Test ARIE Genesis integration"""
    
    def setUp(self):
        self.bus = MagicMock()
        self.engine = MagicMock()
        self.link = ARIEGenesisLink(bus=self.bus, engine=self.engine)
    
    def test_initialization(self):
        """Test ARIEGenesisLink initialization"""
        self.assertIsNotNone(self.link)
        self.assertTrue(self.link.enabled)
    
    def test_registers_subscriptions(self):
        """Test that subscriptions are registered"""
        bus = MagicMock()
        link = ARIEGenesisLink(bus=bus, engine=self.engine)
        
        # Should subscribe to deploy.platform.success and genesis.heal
        self.assertTrue(bus.subscribe.called)
        
        # Check that correct topics were subscribed
        call_args = [call[0][0] for call in bus.subscribe.call_args_list]
        self.assertIn("deploy.platform.success", call_args)
        self.assertIn("genesis.heal", call_args)
    
    @patch('bridge_core.engines.adapters.arie_genesis_link.ARIEGenesisLink._check_permission')
    @patch('bridge_core.engines.adapters.arie_genesis_link.ARIEGenesisLink._publish_audit')
    async def test_on_deploy_success(self, mock_publish, mock_permission):
        """Test deploy success handler"""
        mock_permission.return_value = True
        mock_publish.return_value = None
        
        # Mock engine run
        mock_summary = MagicMock()
        mock_summary.findings_count = 5
        self.engine.run.return_value = mock_summary
        
        event = {
            "platform": "render",
            "deployment_id": "test_123",
            "timestamp": datetime.now(UTC).isoformat() + "Z"
        }
        
        await self.link._on_deploy_success(event)
        
        # Should run scan
        self.assertTrue(self.engine.run.called)


class TestARIEPermissionLink(unittest.TestCase):
    """Test ARIE Permission integration"""
    
    def setUp(self):
        self.link = ARIEPermissionLink()
    
    def test_default_policy(self):
        """Test default RBAC policy"""
        policy = self.link.policy
        
        # Check default permissions
        self.assertIn("captain", policy["arie:scan"])
        self.assertIn("admiral", policy["arie:scan"])
        self.assertIn("admiral", policy["arie:fix"])
        self.assertIn("admiral", policy["arie:rollback"])
    
    async def test_check_capability_scan(self):
        """Test capability check for scan"""
        # Captain should have scan capability
        has_cap = await self.link.check_capability("captain", "arie:scan")
        self.assertTrue(has_cap)
        
        # Admiral should have scan capability
        has_cap = await self.link.check_capability("admiral", "arie:scan")
        self.assertTrue(has_cap)
    
    async def test_check_capability_fix(self):
        """Test capability check for fix"""
        # Captain should NOT have fix capability
        has_cap = await self.link.check_capability("captain", "arie:fix")
        self.assertFalse(has_cap)
        
        # Admiral should have fix capability
        has_cap = await self.link.check_capability("admiral", "arie:fix")
        self.assertTrue(has_cap)
    
    def test_update_policy(self):
        """Test policy update"""
        self.link.update_policy("arie:scan", ["admiral", "captain", "crew"])
        
        policy = self.link.get_policy()
        self.assertIn("crew", policy["arie:scan"])


class TestARIETruthLink(unittest.TestCase):
    """Test ARIE Truth Engine integration"""
    
    def setUp(self):
        self.truth_engine = MagicMock()
        self.arie_engine = MagicMock()
        self.link = ARIETruthLink(
            truth_engine=self.truth_engine,
            arie_engine=self.arie_engine
        )
    
    async def test_certify_patch_success(self):
        """Test successful patch certification"""
        patch = Patch(
            id="test_patch",
            plan_id="test_plan",
            timestamp=datetime.now(UTC).isoformat() + "Z",
            files_modified=["test.py"],
            diff="test diff",
            certified=False
        )
        
        # Mock Truth Engine to return success
        self.truth_engine.verify = AsyncMock(return_value={
            "certified": True,
            "certificate_id": "cert_123"
        })
        
        result = await self.link.certify_patch(patch)
        
        self.assertTrue(result["certified"])
        self.assertEqual(result["certificate_id"], "cert_123")
        self.assertTrue(patch.certified)
    
    async def test_certify_patch_failure_triggers_rollback(self):
        """Test failed certification triggers rollback"""
        patch = Patch(
            id="test_patch",
            plan_id="test_plan",
            timestamp=datetime.now(UTC).isoformat() + "Z",
            files_modified=["test.py"],
            diff="test diff",
            certified=False
        )
        
        # Mock Truth Engine to return failure
        self.truth_engine.verify = AsyncMock(return_value={
            "certified": False,
            "reason": "Tests failed"
        })
        
        # Mock rollback
        self.arie_engine.rollback.return_value = MagicMock(success=True)
        
        result = await self.link.certify_patch(patch)
        
        self.assertFalse(result["certified"])
        # Should trigger rollback
        self.assertTrue(self.arie_engine.rollback.called)


class TestARIECascadeLink(unittest.TestCase):
    """Test ARIE Cascade integration"""
    
    def setUp(self):
        self.cascade_engine = MagicMock()
        self.bus = MagicMock()
        self.link = ARIECascadeLink(
            cascade_engine=self.cascade_engine,
            bus=self.bus
        )
    
    async def test_trigger_post_fix_cascade(self):
        """Test post-fix cascade trigger"""
        summary = Summary(
            run_id="test_run",
            timestamp=datetime.now(UTC).isoformat() + "Z",
            policy=PolicyType.SAFE_EDIT,
            dry_run=False,
            findings_count=10,
            findings_by_severity={},
            findings_by_category={},
            fixes_applied=5,
            duration_seconds=1.0,
            findings=[],
            patches=[]
        )
        
        self.bus.publish = AsyncMock()
        
        await self.link.trigger_post_fix_cascade(summary)
        
        # Should publish parity check
        self.assertTrue(self.bus.publish.called)
    
    async def test_skips_cascade_without_fixes(self):
        """Test cascade is skipped when no fixes applied"""
        summary = Summary(
            run_id="test_run",
            timestamp=datetime.now(UTC).isoformat() + "Z",
            policy=PolicyType.LINT_ONLY,
            dry_run=True,
            findings_count=10,
            findings_by_severity={},
            findings_by_category={},
            fixes_applied=0,  # No fixes
            duration_seconds=1.0,
            findings=[],
            patches=[]
        )
        
        self.bus.publish = AsyncMock()
        
        await self.link.trigger_post_fix_cascade(summary)
        
        # Should not publish anything
        self.assertFalse(self.bus.publish.called)


class TestARIEBlueprintLink(unittest.TestCase):
    """Test ARIE Blueprint integration"""
    
    def setUp(self):
        self.blueprint_registry = MagicMock()
        self.link = ARIEBlueprintLink(blueprint_registry=self.blueprint_registry)
    
    async def test_record_structural_changes(self):
        """Test recording structural changes"""
        from engines.arie.models import Finding
        
        summary = Summary(
            run_id="test_run",
            timestamp=datetime.now(UTC).isoformat() + "Z",
            policy=PolicyType.REFACTOR,
            dry_run=False,
            findings_count=5,
            findings_by_severity={},
            findings_by_category={},
            fixes_applied=3,
            duration_seconds=1.0,
            findings=[
                Finding(
                    id="test_finding",
                    analyzer="route_registry",
                    severity="high",
                    category="route_integrity",
                    file_path="routes/test.py",
                    description="Test finding"
                )
            ],
            patches=[
                Patch(
                    id="test_patch",
                    plan_id="test_plan",
                    timestamp=datetime.now(UTC).isoformat() + "Z",
                    files_modified=["engines/test/routes.py"],
                    diff="test diff",
                    certified=True
                )
            ]
        )
        
        await self.link.record_structural_changes(summary)
        
        # Should process without error
        # (actual Blueprint updates would be tested in integration tests)
    
    def test_extract_module_changes(self):
        """Test extracting module changes from patches"""
        summary = Summary(
            run_id="test_run",
            timestamp=datetime.now(UTC).isoformat() + "Z",
            policy=PolicyType.REFACTOR,
            dry_run=False,
            findings_count=0,
            findings_by_severity={},
            findings_by_category={},
            fixes_applied=1,
            duration_seconds=1.0,
            findings=[],
            patches=[
                Patch(
                    id="test_patch",
                    plan_id="test_plan",
                    timestamp=datetime.now(UTC).isoformat() + "Z",
                    files_modified=["bridge_backend/engines/arie/core.py"],
                    diff="test diff",
                    certified=True
                )
            ]
        )
        
        changes = self.link._extract_module_changes(summary)
        
        self.assertGreater(len(changes), 0)
        self.assertEqual(changes[0]["module"], "arie")


if __name__ == '__main__':
    # Run async tests
    import asyncio
    
    suite = unittest.TestLoader().loadTestsFromModule(sys.modules[__name__])
    runner = unittest.TextTestRunner(verbosity=2)
    
    # Patch asyncio.run for async tests
    original_run = asyncio.run
    
    def patched_test_run(test_method):
        if asyncio.iscoroutinefunction(test_method):
            return original_run(test_method())
        return test_method()
    
    result = runner.run(suite)
    sys.exit(0 if result.wasSuccessful() else 1)
